/* Copyright 2012-2013 Sam Elsamman
 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/**********************************************************************************************************
 * Usage:

 <script src="/node_modules/semotus/client.js">
 <script src="path/file1.js"></script>
 <script src="path/file2.js"></script>

 semotus.importTemplates()
 semotus.establishClientSession(....)

 // path/file1.js:
 module.exports.file1 = function (objectTemplate, getTemplate)
 {
	var Class2 = getTemplate('path/file2.js').Class2
	var Class1 = objectTemplate.create({
	init: function () {var x = new Class2()}
});
return {
	Class1: Class1
	}
};

 // path/file2.js:
 module.exports.file2 = function (objectTemplate, getTemplate)
 {
	var Class2 = objectTemplate.create({
	});
return {
	Class2: Class2
	}
};
 *********************************************************************************************************/

var module = {exports: {}}

var semotus = {
	initializationData: "",
	lastServerInteraction: (new Date()).getTime(),
	setInitialMessage: function (message) {
		this.initializationData = message;
	},
	maxAlerts: 5,
	shutdown: false,
	sequence: 1,
	/**
	 * start a session with the server and process any initial messages
	 *
	 * @param url - of the semotus message handler (usually /semotus)
	 * @param rootCallback - callback that will passed the root object
	 * @param renderCallback - callback to render UI changes upon receipt of message
	 *
	 */
	establishClientSession: function(getControllerTemplate, newSessionCallback, renderCallback, appVersion, reload, offline) {

		this.importTemplates();

		if (appVersion == "0")
			appVersion = null;

		//data = JSON.parse(data);
		this.url = this.initializationData.url;
		this.controllerTemplate = getControllerTemplate;
		this.sessionCallback = newSessionCallback;
		this.renderCallback = renderCallback;
		var self = this;
		this.sendMessage = function (message) {
			message.sequence = self.sequence++;
			console.log ("sending " + message.type + " " + message.name);
			self.lastServerInteraction = (new Date()).getTime();
			self._post(self.url, message,
				function (request) {
					var message = JSON.parse(request.responseText);
					console.log("receiving " + message.type + " " + message.name + " serverAppVersion=" + message.ver);
					if (appVersion && message.ver != appVersion) {
						console.log("Application version " + appVersion + " out of date - " +
								    message.ver + " is available - reloading in 5 seconds");
						self.shutdown = true;
						reload();
						return;
					}
					if (message.newSession || message.type == "refresh")
						self._reset(message);
					else {
						RemoteObjectTemplate.processMessage(message);
						if (self.renderCallback)
							self.renderCallback();
					}
					if (message.sync === false)
						self.refreshSession();
				}, function (err) {
					if (offline)
						offline.call();
					else if (--self.maxAlerts > 0)
						alert("Error on server: " + err);
				});
		}
		this._reset(this.initializationData.message, appVersion, reload);
	},
	resetSession: function () {
		this.sendMessage({type: 'reset'});
	},
	refreshSession: function () {
		this.sendMessage({type: 'refresh'});
	},
	_reset: function (message, appVersion, reload) {
		RemoteObjectTemplate.createSession('client', this.sendMessage);
		RemoteObjectTemplate.setMinimumSequence(message.startingSequence);
		var controllerTemplate = this.controllerTemplate.call();
		var controller = RemoteObjectTemplate._createEmptyObject(controllerTemplate, message.rootId);
		if (appVersion && message.ver != appVersion) {
			console.log("Application version " + appVersion + " out of date - " +
				message.ver + " is available - reloading in 5 seconds");
			this.shutdown = true;
			this.sessionCallback.call(null, controller, message.sessionExpiration);
			reload();
			return;
		}
		RemoteObjectTemplate.syncSession();
		RemoteObjectTemplate.processMessage(message);
		this.sessionCallback.call(null, controller, message.sessionExpiration);
	},
	_post: function (url, message, success, failure) {
		if (this.shutdown)
			return;
		var request = this.getxhr();
		request.open('POST', url, true);
		request.setRequestHeader("Content-Type", "application/json");
		request.onreadystatechange = function () {
			if (request.readyState != 4)
				return;

			try {
				var status = request.status;
				var statusText = request.statusText;
			} catch (e) {
				var status = 666;
				var statusText = 'unknown';
			}
			if (status == 200 || status == 0) {
				console.log("Got response for: " + message.type + " " + message.name);
				success.call(this, request)
			} else {
				console.log("Error: " + message.type + " " + message.name + " status: " + status + " - " + statusText);
				failure.call(this, status + " - " + statusText);
			}
		}
		try {
			request.send(JSON.stringify(message));
		} catch (e) {
				throw "xhr error " + e.message + " on " + url;
		}
	},
	getxhr: function() {
		try {
			return new XMLHttpRequest();
		} catch (e) {
			try {
				return new ActiveXObject("Msxml2.XMLHTTP");
			} catch (e2) {
				try {
					return new ActiveXObject("Microsoft.XMLHTTP");
				} catch (e3) {
					throw 'No support for XMLHTTP';
				}
			}
		}
	},
	/**
	 * Import templates by calling each property of exports, dividing them into two rounds
	 * and starting with the non _mixin
	 */
	importTemplates: function () {
		var requires = {}
		for (var exp in module.exports) {
			if (!exp.match(/_mixins/)) {
				var templates = (module.exports[exp])(RemoteObjectTemplate, function () {return window});
				requires[exp] = templates;
				for (var template in  templates)
					window[template] = templates[template];
			}
		}
		for (var exp in module.exports) {
			if (exp.match(/_mixins/)) {
				var templates = (module.exports[exp])(RemoteObjectTemplate, requires);
				for (var template in  templates)
					window[template] = templates[template];
			}
		}
	}
}
