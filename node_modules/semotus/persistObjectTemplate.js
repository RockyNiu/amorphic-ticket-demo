/* Copyright 2012-2013 Sam Elsamman
 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 *
 * persistObjectTemplate is a mixin for remoteObjectTemplate which allows objects to be
 * persisted in some data store.  The key functions which can only be executed on the server are:
 *
 * - Save an object to a document / table which will either
 *   - create a new document
 *   - update and existing document
 *
 * - Retrieve an object from persistence given either
 *   - A primary key (object id)
 *   - A search criteria
 *   - A primary key reference driven by a relationship with another object
 *
 * All objects have unique ids dispensed by remoteObjectTemplate and these are the
 * id's that are exposed to the client.  The database unique id's are never
 * transported to or from the client to ensure they are not manipulated.
 *
 * The save operation will synchronize a set of related objects.  It does this by
 * determining whether the related objects are dirty, new or removed and performs
 * all appropriate key management and save operations.
 *
 */
/**
 *
 * @param objectTemplate
 * @param RemoteObjectTemplate
 * @param baseClassForPersist
 */
var nextId = 1;
module.exports = function (ObjectTemplate, RemoteObjectTemplate, baseClassForPersist) {

    var Q = require('q');
    /**
     *
     * @type {PersistObjectTemplate}
     */
    var PersistObjectTemplate = baseClassForPersist._createObject();
    PersistObjectTemplate.__id__ = nextId++;
    PersistObjectTemplate._superClass = baseClassForPersist;

    PersistObjectTemplate.setDBURI = function (uri) {
        this._dbURI = uri;
    }
    PersistObjectTemplate.setDB = function (db) {
        this._db = db;
    }
    PersistObjectTemplate.setSchema = function (schema) {
        this._schema = schema;
    }

    PersistObjectTemplate._injectIntoObject = function (object)
    {
        object.persistSave = function () {
            return PersistObjectTemplate.persistSave(object)
                .then (function (obj) {
                return Q.fcall(function() {return obj._id.toString()});
            });
        };
        object.persistDelete = function () {
            return PersistObjectTemplate.deleteFromQuery(object.__template__, {_id: object._id})
        };
        object.setDirty = function () {
            this.__dirty__ = true;
        };
        object.isDirty = function () {
            return this['__dirty__'] ? true : false
        };
        object.fetch = function (properties) {
                return this.resolveRecursivePromises(this.fromDBPOJO(pojos[ix], object.__template__, null, null, null, properties, obj, properties));
        };
    };

    /* Inject some functions into the template */
    PersistObjectTemplate._injectIntoTemplate = function (template)
    {
        /**
         * Return a single instance of an object of this class given an id
         *
         * @param id
         */
        template.getFromPersistWithId = function(id) {
            return PersistObjectTemplate.getFromPersistWithId(template, id)
        };

        /**
         * Return an array of objects of this class given a json query
         *
         * @param query
         */
        template.getFromPersistWithQuery = function(query) {
            return PersistObjectTemplate.getFromPersistWithQuery(template, query)
        };
        /**
         * Delete objects given a json query
         *
         * @param query
         */
        template.deleteFromPersistWithQuery = function(query) {
            return PersistObjectTemplate.deleteFromQuery(template, query)
        };

        /**
         * Return count of objects of this class given a json query
         *
         * @param query
         */
        template.countFromPersistWithQuery = function(query) {
            return PersistObjectTemplate.countFromQuery(template, query)
        };
        /**
         * Return an array of distinct values for a field given a json query
         *
         * @param query
         */
        template.distinctFromPersistWithQuery = function(field, query) {
            return PersistObjectTemplate.distinctFromQuery(template, field, query)
        };

    }

    /**
     * Remove object from a collection/table, optionally removing
     * any dependent objects or references
     *
     * @param options
     */
    PersistObjectTemplate.deleteFromPersistWithQuery = function(template, query) {
        return this.getFromPersistWithQuery(template, query).then (function (obj) {
            return obj.persistDelete();
        });
    }

    PersistObjectTemplate.getFromPersistWithQuery = function (template, query) {
        return this.getPOJOFromQuery(template, query).then(function(pojos) {
            var promises = [];
            var results = [];
            for (var ix = 0; ix < pojos.length; ++ix)
                (function () {
                    var cix = ix;
                    promises.push(this.fromDBPOJO(pojos[ix], template).then( function (obj) {
                        results[cix] = obj;
                    }))
                }.bind(this))();
            return this.resolveRecursivePromises(promises, results);
        }.bind(this));
    }
    PersistObjectTemplate.getFromPersistWithId = function (template, id) {
        var self = this;
        return this.getPOJOFromQuery(template, {_id: new ObjectID(id)}).then(function(pojos) {
            if (pojos.length > 0)
                return self.fromDBPOJO(pojos[0], template);
            else
                throw "Cannot find record";
        });
    }

    /**
     * Enriches a "Plane Old JavaScript Object (POJO)" by creating it using the new Operator
     * so that all prototype information such as functions are created. It will reconstruct
     * references one-to-one and one-two-many by reading them from the database
     *  *
     * @param pojo is the anadorned object
     * @param template is the template used to create the object
     * @return {*} an object via a promise as though it was created with new template()
     */
    PersistObjectTemplate.fromDBPOJO = function (pojo, template, promises, defineProperty, idMap, cascade, establishedObj, specificProperties)
    {
        // For recording back refs
        if (!idMap)
            idMap = {};
        var topLevel = false;
        if (!promises) {
            topLevel = true;
            promises = [];
        }

        // Create the new object with correct constructor using embedded ID if ObjectTemplate
        var obj = establishedObj ||
            this._createEmptyObject(template, 'perist-' + pojo._template + "-"+ pojo._id.toString(), defineProperty);
        var collection = obj.__template__.__collection__;
        var schema = this._schema[obj.__template__.__collection__];
        var id = pojo._id;
        obj._id = id;
        idMap[id.toString()] = obj;

        // Go through all the properties and transfer them to newly created object
        var props = specificProperties || obj.__template__.getProperties();
        for (var prop in props)
        {
            var value = pojo[prop];
            var defineProperty = props[prop];
            var type = defineProperty.type;
            var of = defineProperty.of;
            // See if this a reference to another doc
            var isCrossDocRef = (of && of.__collection__ && of.__collection__ != collection) ||
                (type && type.__collection__ && type.__collection__ != collection);
            var cascadeFetch = (cascade && typeof(cascade[prop]) != 'undefined') ? cascade[prop] : defineProperty['fetch'];

            // Make sure this is property is persistent and that it has a value.  We have to skip
            // undefined values in case a new property is added so it can retain it's default value
            //@@@ Not sure this should test for null as you should be able to store null values
            if (!this._persistProperty(defineProperty) || !defineProperty.enumerable ||
                (!isCrossDocRef && (typeof(value) == "undefined" || value == null)))
                continue;
            if (!type)
                throw obj.__template__.name + "." + prop + " has no type decleration";

            if (type == Array)
            {
                // If type of pojo
                if (!defineProperty.of.__collection__)
                    obj[prop] = value;
                // If this is in the same entity just copy over
                else if (defineProperty.of.__collection__ == collection)
                {
                    obj[prop] = [];
                    for (var ix = 0; ix < pojo[prop].length; ++ix)
                        obj[prop][ix] = pojo[prop][ix] ?
                            (typeof(pojo[prop][ix]) == "string" ?
                                idMap[pojo[prop][ix]] :
                                this.fromDBPOJO(pojo[prop][ix], defineProperty.of, promises, defineProperty, idMap))
                            : null;
                }
                // Otherwise this is a database reference and we have to find the collection of kids
                else if (cascadeFetch)
                {
                    var foreignKey = schema.children[prop].id;
                    var query = {};
                    query[foreignKey] = id;
                    var self = this;
                    (function () {
                        var closureProp = prop;
                        var closureOf = defineProperty.of;
                        promises.push(self.getPOJOFromQuery(closureOf, query).then( function(pojos) {
                            for(var ix = 0; ix < pojos.length; ++ix) {
                                if (idMap[pojos[ix]._id.toString()])
                                    obj[closureProp][ix] = idMap[pojos[ix]._id.toString()];
                                else
                                    obj[closureProp][ix] = self.fromDBPOJO(pojos[ix], closureOf, promises, defineProperty, idMap, cascadeFetch)
                            }
                            return Q.fcall(function(){return true}); // Say we done
                        }));
                    })();
                }
            } else if (type.isObjectTemplate) {
                // Same collection suck in from idMap if previously referenced or process pojo
                if (type.__collection__ == collection) {
                    var newObject = pojo[prop] ? (typeof(pojo[prop]) == "string" ? idMap[pojo[prop]] :
                        this.fromDBPOJO(pojo[prop], type, promises, defineProperty, idMap))	: null;
                    obj[prop] = newObject;
                    // Otherwise read from idMap or query for it
                } else if (cascadeFetch) {
                    var foreignKey = this._schema[collection].parents[prop].id;
                    if (!foreignKey)
                        throw "Incorrect schema entry for " + collection + " while processing " + template._name;
                    if (idMap[(pojo[foreignKey] || "").toString()])
                        obj[prop] = idMap[pojo[foreignKey].toString()];
                    else if (pojo[foreignKey]) {
                        var query = {_id: pojo[foreignKey]};
                        var self = this;
                        (function () {
                            var closureProp = prop;
                            var closureType = type;
                            promises.push(self.getPOJOFromQuery(closureType, query).then(function(pojos) {
                                if (pojos.length > 0) {
                                    obj[closureProp] = self.fromDBPOJO(pojos[0], closureType, promises, defineProperty, idMap, cascadeFetch);
                                    return Q.fcall(function(){return true});
                                } else
                                    obj[prop] = null;
                            }));
                        })();
                    }
                }
            } else
            if (typeof(pojo[prop]) != 'undefined') {
                if (type == Date)
                    obj[prop] = pojo[prop] ? new Date(pojo[prop]) : null;
                else
                    obj[prop] = pojo[prop];
            }
        }
        if (topLevel)
            return this.resolveRecursivePromises(promises, obj);
        else
            return obj;
    };
    PersistObjectTemplate.resolveRecursivePromises = function(promises, returnValue) {
        var promisesToResolve = promises.length;
        return Q.all(promises).then(function() {
            promises.splice(0, promisesToResolve);
            return promises.length > 0 ? PersistObjectTemplate.resolveRecursivePromises(promises, returnValue)
                : Q.fcall(function(){return returnValue});
        });
    }

    /**
     * Save the object to persistent storage
     *
     * A copy of the object is made which has only the persistent properties
     * and all objects references for objects not stored in the the document
     * replaced by foreign keys.  Arrays of objects not stored in the document
     * are adjusted such that their foreign keys point back to this object.
     * Any related objects stored in other documents are also saved.
     *
     * @param obj  Only required parameter - the object to be saved
     * @param promises
     * @param masterId
     * @param idMap
     * @return {*}
     */
    PersistObjectTemplate.persistSave = function(obj, promises, masterId, idMap)
    {
        if (!this._schema)
            throw "Please call setSchema before doing calling persistSave";
        var schema = this._schema[obj.__template__.__collection__];
        var collection = obj.__template__.__collection__;
        var resolvePromises = false;    // whether we resolve all promises
        var savePOJO = false;           // whether we save this entity or just return pojo

        if (!promises) {                // accumulate promises for nested saves
            promises = [];
            resolvePromises = true;
        }

        var topLevel = false;       // top level returns a promise

        var id = obj._id ?
            (obj._id.toString().match(/:/) ?
                obj._id :
                (obj._id instanceof ObjectID ? obj._id :	new ObjectID(obj._id))) :
            this.getDBID(masterId);
        obj._id = id;
        obj.__dirty__ = false;

        if (!masterId) {
            savePOJO = true;
            masterId = id;
            idMap = {};             // Track circular references
        }

        var pojo = {_id: id, _template: obj.__template__._name};   // subsequent levels return pojo copy of object
        idMap[id.toString()] = pojo;

        // Enumerate all template properties for the object
        var props = obj.__template__.getProperties();
        for (var prop in props)
        {
            var defineProperty = props[prop];
            var value = obj[prop];
            if (!this._persistProperty(defineProperty) || !defineProperty.enumerable ||
                typeof(value) == "undefined" || value == null)
                continue;

            // For arrays we either just copy each element or link and save each element
            if (defineProperty.type == Array)
            {
                if (!defineProperty.of)
                    throw obj.__template__._name + "." + prop + " is an Array with no 'of' declaration";

                // If type of pojo
                if (!defineProperty.of.__collection__)
                    pojo[prop] = value;
                // If this is in the same entity just copy
                else if (defineProperty.of.__collection__ == collection)
                {
                    pojo[prop] = [];
                    if (value)
                        for (var ix = 0; ix < value.length; ++ix)
                            if (value[ix]._id && idMap[value[ix]._id.toString()]) // Previously referenced objects just get the id
                                pojo[prop][ix] = value[ix]._id.toString();
                            else // Otherwise recursively obtain pojo
                                pojo[prop][ix] = this.persistSave(value[ix], promises, masterId, idMap);

                    // Otherwise this is a database reference and we must make sure that the
                    // foreign key points back to the id of this entity
                } else {
                    if (value instanceof Array)
                        for (var ix = 0; ix < value.length; ++ix)
                        {
                            if (!schema.children[prop])
                                throw "Missing children schema entry for " + prop + " in " + obj.__template__._name;
                            var foreignKey = schema.children[prop].id;
                            if (!value[ix][foreignKey] || value[ix][foreignKey].toString() != id.toString()) {
                                value[ix][foreignKey] = id;
                                value[ix].__dirty__ = true;;
                            }
                            if (value[ix].__dirty__)
                                promises.push(this.persistSave(value[ix], promises, null, idMap));
                        }
                }
            }
            else if (defineProperty.type && defineProperty.type.isObjectTemplate)
            {
                // If this is in the same entity just copy over
                if (defineProperty.type.__collection__ == collection)
                {
                    if (value._id && idMap[value._id.toString()])
                        pojo[prop] = value._id.toString();
                    else
                        pojo[prop] = this.persistSave(value, promises, masterId, idMap);
                }
                // Otherwise this is a database reference and we must make sure that we
                // have a foreign key that points to the entity
                else
                {
                    var foreignKey = schema.parents[prop].id;
                    // Make sure referenced entity has an id
                    if (!value._id) {
                        value._id = this.getDBID(); // Create one
                        value.__dirty__ = true;     // Will need to be saved
                    }
                    // Make sure we point to that id
                    if (!obj[foreignKey] || obj[foreignKey].toString != value._id.toString()) {
                        obj[foreignKey] = value._id;
                    }
                    pojo[foreignKey] = obj[foreignKey];
                    if (value.__dirty__)
                        promises.push(this.persistSave(value, promises, null, idMap));
                }
            }
            else if (defineProperty.type == Date)
                pojo[prop] = obj[prop] ? obj[prop].getTime() : null;
            else
                pojo[prop] = obj[prop];
        }

        if (savePOJO)
            promises.push(this.savePOJO(obj, pojo));
        if (resolvePromises)
            return this.resolveRecursivePromises(promises, pojo);
        else
            return pojo;
    }

    PersistObjectTemplate._persistProperty = function(defineProperty) {
        if (defineProperty.persist == false || defineProperty.isLocal == true)
            return false
        else
            return true;
    }
    var ObjectID = require('mongodb').ObjectID;

    /* Mongo implementation of open */
    PersistObjectTemplate.getDB = function()
    {
        if (!this._db)
            throw "You must do PersistObjectTempate.setDB()";
        return this._db;
    }

    /* Mongo implementation of save */
    PersistObjectTemplate.savePOJO = function(obj, pojo) {
        return Q.ninvoke(this.getDB(), "collection", obj.__template__.__collection__).then (function (collection) {
            return Q.ninvoke(collection, "save", pojo);
        });
    }
    PersistObjectTemplate.deleteFromQuery = function(template, query) {
        return Q.ninvoke(this.getDB(), "collection", template.__collection__, {w:1, fsync:true}).then (function (collection) {
            return Q.ninvoke(collection, "remove", query);
        });
    }
    PersistObjectTemplate.getPOJOFromQuery = function(template, query) {
        return Q.ninvoke(this.getDB(), "collection", template.__collection__).then (function (collection) {
            return Q.ninvoke(collection, "find", query).then( function (cursor) {
                return Q.ninvoke(cursor, "count", false).then(
                    function(count) {
                        return Q.ninvoke(cursor, "toArray")
                    },
                    function(error) {
                        console.log(error);
                        return Q.fcall(function () {return []});
                    }
                );
            });
        });
    }
    PersistObjectTemplate.countFromQuery = function(template, query) {
        return Q.ninvoke(this.getDB(), "collection", template.__collection__).then (function (collection) {
            return Q.ninvoke(collection, "find", query).then( function (cursor) {
                return Q.ninvoke(cursor, "count", false);
            });
        });
    }
    PersistObjectTemplate.distinctFromQuery = function(template, field, query) {
        return Q.ninvoke(this.getDB(), "collection", template.__collection__).then (function (collection) {
            return Q.ninvoke(collection, "distinct", field, query)
        });
    }
    PersistObjectTemplate.getDBID = function (masterId)
    {
        if (!masterId)
            return new ObjectID();
        else
            return masterId.toString() + ":" + new ObjectID().toString();

    }

    return  PersistObjectTemplate;
}